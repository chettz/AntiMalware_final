#include "dbfile.h"
#include <fstream>
#include <filesystem>

namespace dbfile
{
    // DB 파일 저장 시 사용할 파일명 설정을 위한 함수
    void DBFile::setDBFileName(const tstring_view& dbFileName)
    {
        if (!dbFileName.empty())
        {
            malwareDBFileName_ = dbFileName;
        }
    };

    // BYTE 배열에서 특정 위치의 bit 값을 설정하기 위한 함수
    void DBFile::setBit(BinaryData& bloomFilter, const DWORD bitIndex)
    {
        bloomFilter[bitIndex / 8] |= BIT_FLAG[7 - (bitIndex % 8)];
    };

    // CSV 파일에 저장되어 있는 탐지 해시와 탐지명 정보를 읽어서 DetectHashInfoList에 저장
    bool DBFile::getDetectHashInfo(const tstring& csvFilePath, DetectHashInfoList& detectHashInfoList)
	{
        bool result = false;
        size_t strPos;
        tstring hashString;
        u8string nameString;
        u8ifstream csvFile;  // UTF-8 문자열을 처리하기 위한 파일 스트림

        csvFile.open(csvFilePath, ios::in); // 텍스트 파일로 오픈
        if (csvFile.is_open())
        {
            for (u8string line; getline(csvFile, line);)
            {
                strPos = line.find(',');
                if ((strPos != string::npos) && (strPos > 0))
                {
                    hashString = strConv_.to_tstring(line.substr(0, strPos));
                    nameString = line.substr(strPos + 1);

                    hashString.erase(0, hashString.find_first_not_of(_T(" \t\n\r\f\v"))); // ltrim
                    hashString.erase(hashString.find_last_not_of(_T(" \t\n\r\f\v")) + 1); // rtrim
                    nameString.erase(0, nameString.find_first_not_of(u8" \t\n\r\f\v")); // ltrim
                    nameString.erase(nameString.find_last_not_of(u8" \t\n\r\f\v") + 1); // rtrim

                    if (!hashString.empty() && !nameString.empty())
                    {
                        result = true;
                        detectHashInfoList.push_back(
                            DetectHashInfo{ nameString, hash_.getHashBytesFromHexString(hashString) }
                        );
                    }
                }
            }
            csvFile.close();
        }
        else
        {
            logger_.log(format(_T("Can't open csv file : {}"), csvFilePath), LOG_LEVEL_ERROR);
        }
        return result;
	};

    // BinaryData를 파일로 저장하기 위한 함수
    bool DBFile::saveDataToFile(const tstring& saveFilePath, const BinaryData& binaryData) const
    {
        bool result = false;
        ofstream fileOut; 

        // 바이너리 파일로 오픈 (기존에 파일이 있으면 지움 - ios::trunc)
        fileOut.open(saveFilePath, ios::out | ios::binary | ios::trunc); 

        if (fileOut.is_open())
        {
            write_typed_data(fileOut, binaryData, binaryData.size());

            fileOut.close();
            result = true;
        }
        else
        {
            logger_.log(format(_T("Can't save file : {}"), saveFilePath), LOG_LEVEL_ERROR);
        }
        return result;
    };

    // 블룸 필터 파일 생성, 블룸 필터는 24bit, 16,777,216 bit를 이용, 총 6개의 해시 함수 사용
    bool DBFile::makeBloomFilterDB(const tstring& dirPath, const DetectHashInfoList& detectHashInoList, DetectCrc16List& crc16List)
    {
        bool result = false;
        WORD crc16Value = 0;
        BYTE bitHashValue24[BYTE_COUNT_DWORD] = { 0, };
        tstring filePath = filesystem::path(dirPath).append(malwareDBFileName_).c_str() + malwareFilterExt_;
        BinaryData binaryData;

        binaryData.assign(bloomFilterSize_, 0);

        for (const auto& element : detectHashInoList)
        {
            const BinaryData& hashData = element.DetectHash;
            if (hashData.size() > 0)
            {
                // CRC16 해시 계산
                if (hash_.open(HASH_TYPE_CRC16))
                {
                    hash_.calculateHash(hashData.data(), static_cast<DWORD>(hashData.size()));
                    crc16Value = *(reinterpret_cast<const WORD*>(hash_.getHashBytes().data()));
                    hash_.close();
                }

                // CRC16 +  MD5 첫번째 바이트 (첫 번째 해시 함수 대체)
                memcpy(bitHashValue24, &crc16Value, sizeof(WORD));
                bitHashValue24[2] = hashData.data()[0];
                setBit(binaryData, *(reinterpret_cast<PDWORD>(bitHashValue24)));

                // MD5 해시 값 hashData[1] ~ hashData[3] 바이트 값 (두 번째 해시 함수 대체)
                memcpy(bitHashValue24, (hashData.data() + 1), BYTE_COUNT_24BIT);
                setBit(binaryData, *(reinterpret_cast<PDWORD>(bitHashValue24)));

                // MD5 해시 값 hashData[4] ~ hashData[6] 바이트 값 (세 번째 해시 함수 대체)
                memcpy(bitHashValue24, (hashData.data() + 4), BYTE_COUNT_24BIT);
                setBit(binaryData, *(reinterpret_cast<PDWORD>(bitHashValue24)));

                // MD5 해시 값 hashData[7] ~ hashData[9] 바이트 값 (네 번째 해시 함수 대체)
                memcpy(bitHashValue24, (hashData.data() + 7), BYTE_COUNT_24BIT);
                setBit(binaryData, *(reinterpret_cast<PDWORD>(bitHashValue24)));

                // MD5 해시 값 hashData[10] ~ hashData[12] 바이트 값 (다섯 번째 해시 함수 대체)
                memcpy(bitHashValue24, (hashData.data() + 10), BYTE_COUNT_24BIT);
                setBit(binaryData, *(reinterpret_cast<PDWORD>(bitHashValue24)));

                // MD5 해시 값 hashData[13] ~ hashData[15] 바이트 값 (여섯 번째 해시 함수 대체)
                memcpy(bitHashValue24, (hashData.data() + 13), BYTE_COUNT_24BIT);
                setBit(binaryData, *(reinterpret_cast<PDWORD>(bitHashValue24)));

                // CRC16 해시 값은 해시 테이블 구성에도 사용되기 때문에 목록에 저장
                crc16List.push_back(crc16Value);
            }
            else
            {
                logger_.log(_T("Detect hash infomation is empty!"), LOG_LEVEL_ERROR);
                break;
            }
        }

        // 파일에 저장
        if (!crc16List.empty())
        {
            result = saveDataToFile(filePath, binaryData);
        }
        return result;
    };

    // 탐지 해시 파일 생성
    bool DBFile::makeHashDB(const tstring& dirPath, const DetectHashInfoList& detectHashInoList, 
        const DetectCrc16List& crc16List, const DetectNameInfoMap& detectNameInfoMap)
    {
        bool result = false;
        DWORD nextIndex = 0;
        PDWORD bucketPtr = nullptr;
        DWORD linkedListItemIndex = 0;
        PLINKED_LIST_ITEM linkedListItemPtr = nullptr;
        tstring filePath = filesystem::path(dirPath).append(malwareDBFileName_).c_str() + malwareHashExt_;
        BinaryData binaryData;

        /*
            해시 테이블의 버킷 크기는 16bit = 65536개, 65536 * 4byte = 256kb (262,144 byte)
                - 각 버킷에는 연결된 탐지 정보의 위치(index, DWORD)가 저장됨
            해시 테이블의 Linked list 각 항목은 총 24byte
                - md5 hash(16byte)
                - 탐지명 offset(탐지명 파일 내에서의 offset, DWORD, 4byte)
                - next node index(DWORD, 4byte)
            필요한 버퍼 크기는 256kb + (sizeof(LINKED_LIST_ITEM)=24byte * 저장할 항목 수)
        */
        binaryData.assign(HASH_TABLE_BUCKET_SIZE + (detectHashInoList.size() * sizeof(LINKED_LIST_ITEM)), 0);

        // 버킷의 시작 주소 설정하고 버킷의 초기 값을 -1로 설정
        bucketPtr = reinterpret_cast<PDWORD>(binaryData.data());
        memset(binaryData.data(), -1, HASH_TABLE_BUCKET_SIZE);

        // 실제 해시 정보(LINKED_LIST_ITEM)가 저장될 시작 주소 설정
        linkedListItemPtr = reinterpret_cast<PLINKED_LIST_ITEM>(binaryData.data() + HASH_TABLE_BUCKET_SIZE);
        linkedListItemIndex = 0;

        for (DWORD index = 0; index < detectHashInoList.size(); index++)
        {   
            // detectNameInfoMap에서 탐지명을 검색하여 탐지명의 offset 정보를 구함
            const auto& nameInfo = detectNameInfoMap.find(detectHashInoList[index].DetectName);

            if (nameInfo != detectNameInfoMap.end())
            {
                // 새로운 LINKED_LIST_ITEM 추가
                const BinaryData& detectHash = detectHashInoList[index].DetectHash;
                LINKED_LIST_ITEM& hashItem = linkedListItemPtr[linkedListItemIndex];

                memcpy_s(hashItem.hash, sizeof(hashItem.hash), detectHash.data(), detectHash.size());
                hashItem.detectNameOffset = nameInfo->second;
                hashItem.nextIndex = 0; // 새로운 항목이므로 연결된 항목 없음

                // 버킷에 저장된 값을 읽음(버킷의 index는 crc16List[index] 값)
                nextIndex = bucketPtr[crc16List[index]];

                // 해당 위치의 버킷에 LINKED_LIST_ITEM이 이미 등록되어 있는지 확인
                if (nextIndex == 0xffffffff)
                {
                    // 기존에 등록된 항목이 없기 때문에 해당 버킷의 첫 LINKED_LIST_ITEM으로 등록
                    // LINKED_LIST_ITEM의 주소가 아니라 index 정보를 저장한다는 점 주의
                    bucketPtr[crc16List[index]] = linkedListItemIndex;
                }
                else
                {
                    // 버킷에 등록(이미 등록된 항목이 있는 경우 linked list를 따라가면서 마지막 항목에 추가)
                    do
                    {
                        if (linkedListItemPtr[nextIndex].nextIndex == 0)
                        {
                            // 새로 추가된 탐지 항목의 위치(index)를 설정
                            // LINKED_LIST_ITEM의 주소가 아니라 index 정보를 저장한다는 점 주의
                            linkedListItemPtr[nextIndex].nextIndex = linkedListItemIndex;
                            break;
                        }
                        else
                        {
                            // nextIndex를 연결된 다음 LINKED_LIST_ITEM index로 설정하여 검색 계속
                            nextIndex = linkedListItemPtr[nextIndex].nextIndex;
                        }
                    } 
                    while (nextIndex < detectHashInoList.size());
                }
                linkedListItemIndex++;
            }
            else
            {
                logger_.log(format(_T("Fail to find detect name : {}"), 
                    strConv_.to_tstring(detectHashInoList[index].DetectName)), LOG_LEVEL_ERROR);
            }
        }
        
        // 파일에 저장
        if (!binaryData.empty())
        {
            result = saveDataToFile(filePath, binaryData);
        }
        return result;
    };

    // 탐지명 파일 생성
    bool DBFile::makeNameDB(const tstring& dirPath, const DetectHashInfoList& detectHashInoList, DetectNameInfoMap& detectNameInfoMap)
    {
        bool result = false;
        WORD dataLength = 0;
        DWORD currentOffset = 0;
        ofstream fileOut;  // 파일을 읽기 : ifstream, 파일 쓰기 : ofstream, 읽고 쓰기 : fstream
        tstring filePath = filesystem::path(dirPath).append(malwareDBFileName_).c_str() + malwareNameExt_;
        map<u8string, BOOL> uniqueCheck;

        // 바이너리 파일로 오픈 (기존에 파일이 있으면 지움 - ios::trunc)
        fileOut.open(filePath, ios::out | ios::binary | ios::trunc); 
        if (fileOut.is_open())
        {
            for (const auto& element : detectHashInoList)
            {
                // 중복 체크
                if (uniqueCheck.find(element.DetectName) == uniqueCheck.end())
                {
                    // 현재 offset을 구해서 탐지명과 함께 저장
                    currentOffset = static_cast<DWORD>(fileOut.tellp());
                    detectNameInfoMap.insert(pair(element.DetectName, currentOffset));

                    // 중복 체크용 맵에 탐지명 등록
                    uniqueCheck.insert(pair(element.DetectName, true));

                    //NULL 문자까지 포함한 길이로 설정해서 NULL 문자를 같이 기록
                    dataLength = static_cast<WORD>(element.DetectName.size() + 1);
                    write_typed_data(fileOut, element.DetectName, dataLength);

                    result = true;
                }
            }
            fileOut.close();
        }
        return result;
    };

    // DB 파일들 생성
    bool DBFile::makeDBFile(const tstring& csvFilePath, const tstring& dbDirPath)
    {
        bool result = false;
        DetectHashInfoList detectHashInfoList;      
        DetectNameInfoMap detectNameInfoMap;
        DetectCrc16List crc16List;

        // 탐지 해시 정보 불러오기
        if (getDetectHashInfo(csvFilePath, detectHashInfoList))
        {
            // 탐지 테스트를 위해서 DetectMe 파일들, EICAR 파일의 해시도 추가
            filesystem::path csvFile(csvFilePath + _T(".test"));
            if (filesystem::exists(csvFile))
            {
                getDetectHashInfo(csvFile, detectHashInfoList);
            }

            // 탐지명 파일 생성
            if (makeNameDB(dbDirPath, detectHashInfoList, detectNameInfoMap))
            {
                // 블룸 필터 파일 생성
                if (makeBloomFilterDB(dbDirPath, detectHashInfoList, crc16List))
                {
                    // 탐지 해시 파일 생성
                    result = makeHashDB(dbDirPath, detectHashInfoList, crc16List, detectNameInfoMap);
                }
            }
        }
        return result;
    };
}
      