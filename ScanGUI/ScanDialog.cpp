#include "ScanDialog.h"
#include "ScanDialog.h"

namespace scandialog
{
	// 생성자 - 변수 초기화 및 IPC 오픈
	ScanDialog::ScanDialog() 
		: dialogHwnd_(NULL), listBoxHwnd_(NULL), 
		scanItemCount_(0), scanPathId_(0), scanBtnId_(0),
		selectedDirectory_(SYSTEM_ROOT_PATH), currentScanPath_(_T("")), 
		isAlive_(false), isScanning_(false), isInitilized_(false)
	{
		isInitilized_ = ipc_.open(false);		
	};

	// 소멸자 - IPC 해제
	ScanDialog::~ScanDialog()
	{
		ipc_.close();
	};

	// 현재 선택된 디렉토리
	const tstring& ScanDialog::GetSelectedDirectory(void)
	{
		return selectedDirectory_;
	};

	// 폴더 선택 창 띄움
	bool ScanDialog::BrowseFolder(void)
	{
		bool result = false;
		TCHAR path[MAX_PATH] = { 0, };
		BROWSEINFO bi = { 0 };

		bi.lpszTitle = NULL;
		bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_NONEWFOLDERBUTTON;
		bi.lpfn = NULL;
		bi.lParam = NULL;

		LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
		if (pidl != 0)
		{
			//get the name of the folder and put it in path
			SHGetPathFromIDList(pidl, path);

			//free memory used
			IMalloc* imalloc = 0;
			if (SUCCEEDED(SHGetMalloc(&imalloc)))
			{
				imalloc->Free(pidl);
				imalloc->Release();
			}
			selectedDirectory_ = path;
			result = true;
		}
		return result;
	};

	// 현재 검사 중인 경로를 화면에 표시 할지 여부
	bool ScanDialog::isDisplayScanPath(void)
	{
		// 모든 검사 항목을 다 표시하면 부하가 너무 많이 걸리기 때문에 100개 마다 출력
		if ((scanItemCount_ % DISPLAY_ITEM_SKIP_COUNT) == 0)
		{
			return true;
		}
		return false;
	};

	// 필요한 HWND, ID 설정
	void ScanDialog::setHwnd(const HWND& dialogHwnd, const HWND& listBoxHwnd, const int& scanPathId, const int& scanBtnId)
	{
		dialogHwnd_ = dialogHwnd;
		listBoxHwnd_ = listBoxHwnd;
		scanPathId_ = scanPathId;
		scanBtnId_ = scanBtnId;
	};

	// 파일 검사 요청
	bool ScanDialog::ScanFile(IPC_MESSAGE& ipcMessage, const tstring& filePath, tstring& detectName)
	{
		// 파일 검사 요청을 위한 정보 설정
		ipcMessage.ipcHeader.ipcCommand = IPC_SCAN_FILE;
		ipcMessage.ipcHeader.ipcDataSize = static_cast<DWORD>(filePath.size() + 1) * sizeof(TCHAR);
		ipcMessage.ipcData.resize(ipcMessage.ipcHeader.ipcDataSize);
		memcpy_s(ipcMessage.ipcData.data(), ipcMessage.ipcData.size(), filePath.data(), ipcMessage.ipcHeader.ipcDataSize);

		// 검사 요청
		return ipc_.sendMsg(ipcMessage);
	};

	// 파일 검사 요청
	bool ScanDialog::GetScanResult(IPC_MESSAGE& ipcMessage, tstring& detectName)
	{
		IPCCommandType acceptCommandType = static_cast<IPCCommandType>(IPC_SCAN_RESULT_DETECT | IPC_SCAN_RESULT_NOT_DETECT);

		while (isScanning_)
		{
			// 검사 결과 수신 대기
			if (ipc_.getNextInfo(ipcMessage, acceptCommandType))
			{
				// 탐지 시 탐지명 설정
				if (ipcMessage.ipcHeader.ipcCommand == IPC_SCAN_RESULT_DETECT)
				{
					detectName = reinterpret_cast<TCHAR*>(ipcMessage.ipcData.data());
				}
				break;
			}
		}
		return (!detectName.empty());
	}

	// 검사 스레드
	void ScanDialog::ScanDirectoryThread(void)
	{
		IPC_MESSAGE ipcMessage;
		tstring filePath;
		tstring detectName;
		bool sendMessage = false;
		HWND scanPathHwnd = GetDlgItem(dialogHwnd_, scanPathId_);

		// 스레드 시작 설정
		isAlive_ = true;

		// 최상위 디렉토리 설정
		path parent(selectedDirectory_);

		// Traverse all directories and files recursively
		for (const auto& entry : recursive_directory_iterator(parent, directory_options::skip_permission_denied))
		{
			try
			{
				if (entry.is_regular_file())
				{
					// 검사 대상 파일 경로 설정
					currentScanPath_ = entry.path();

					// 검사 대상 파일 경로 화면에 표시
					if (isDisplayScanPath())
					{
						ShowWindow(scanPathHwnd, SW_HIDE);
						SetDlgItemText(dialogHwnd_, scanPathId_, format(_T("({}) {}"), scanItemCount_, currentScanPath_).c_str());
						ShowWindow(scanPathHwnd, SW_SHOW);
					}

					// 검사 요청
					if (ScanFile(ipcMessage, currentScanPath_, detectName))
					{
						// 검사 결과 수신 - 탐지시 true 리턴
						if (GetScanResult(ipcMessage, detectName))
						{
							// 탐지명 탐지 목록에 등록
							if (listBoxHwnd_ != NULL)
							{
								SendMessage(listBoxHwnd_, LB_ADDSTRING, 0, (LPARAM)format(_T("{}, {}"), detectName, currentScanPath_).c_str());
							}
						}
					}
					detectName.clear();
					scanItemCount_++;
				}
			}
			catch (...)
			{
				continue;
			}
			if (!isScanning_)
			{
				// 스캔 중지
				break;
			}
		}

		// 검사 및 스레드 종료 설정
		isScanning_ = false;
		isAlive_ = false;

		// 검사 종료 화면에 표시
		if (dialogHwnd_ != NULL)
		{
			ShowWindow(scanPathHwnd, SW_HIDE);
			SetDlgItemText(dialogHwnd_, scanPathId_, format(_T("({}) Scan complete."), scanItemCount_).c_str());
			ShowWindow(scanPathHwnd, SW_SHOW);
			SendMessage(dialogHwnd_, WM_COMMAND, scanBtnId_, THREAD_COMPLETE_MESSAGE_LPARAM);
		}
	};
	
	// 검사 시작
	bool ScanDialog::startScan(void)
	{
		bool result = false;

		if (isInitilized_)
		{
			scanItemCount_ = 0;
			isScanning_ = true;

			thread scanDirectoryThread = thread([&]() { ScanDirectoryThread(); });
			scanDirectoryThread.detach();

			result = true;
		}
		else
		{
			MessageBox(dialogHwnd_, _T("IPC is not initialized."), _T("오류"), MB_OK | MB_ICONERROR);
		}
		return result;
	};

	// 검사 중지
	void ScanDialog::stopScan(void)
	{
		if (isScanning_)
		{
			isScanning_ = false;

			// 최대 100ms 만큼 종료 대기
			for (int loop = 0; loop < 100; loop++)
			{
				if (!isAlive_)
				{
					break;
				}
				Sleep(1);
			}
		}
	};

	// 검사 중인지 여부
	bool ScanDialog::isScanning(void)
	{
		return isScanning_;
	};
}

