#include "cmdparser.h"
#include "peparser.h"
#include "hash.h"

using namespace cmdparser;
using namespace peparser;
using namespace hash;

// 옵션 등록
void configureCmdParser(CmdParser& cmdParser)
{
	cmdParser.set_required<tstring>(_T("m"), _T("hash_mode"), _T("Hash excraction mode : b(binary) or c(code) or p(pdb)."));
	cmdParser.set_optional<tstring>(_T("f"), _T("file_path"), _T(""), _T("The target file path."));
	cmdParser.set_optional<DWORD>(_T("p"), _T("process_id"), 0, _T("The target process id."));
	cmdParser.set_optional<int>(_T("u"), _T("use_process_image"), 0, _T("Get hash from process image."));
};

// 옵션 값 읽기
bool readCmdLineOption(CmdParser& cmdParser, tstring& hashMode, tstring& filePath, DWORD& processID, int& useProcessImage)
{
	bool result = false;

	if (cmdParser.isPrintHelp())
	{
		// 도움말 옵션 설정 시 도움말 출력
		tcout << cmdParser.getHelpMessage(_T("HashTool"));
	}
	else
	{
		try
		{
			// 커맨드라인 옵션 읽기
			hashMode = cmdParser.get<tstring>(_T("m"));
			filePath = cmdParser.get<tstring>(_T("f"));
			processID = cmdParser.get<DWORD>(_T("p"));
			useProcessImage = cmdParser.get<int>(_T("u"));

			result = true;
		}
		catch (std::runtime_error ex)
		{
			// 오류 발생 시에 오류 내용과 함께 도움말 출력
			cout << format("Error : {}\n\n", ex.what());
			tcout << cmdParser.getHelpMessage(_T("HashTool"));
		}
	}
	return result;
}

int _tmain(int argc, TCHAR* argv[])
{
	CmdParser cmdParser;

	// 옵션 변수 선언
	tstring hashMode;
	tstring filePath;
	DWORD processID;
	int useProcessImage;

	// 옵션 등록
	configureCmdParser(cmdParser);

	// 커맨드라인 파싱
	cmdParser.parseCmdLine(argc, argv);

	// 옵션 값 읽기
	if (readCmdLineOption(cmdParser, hashMode, filePath, processID, useProcessImage))
	{
		Hash hash;
		PEParser peparser;
		bool isOpen = false;
		bool forceOpen = false;

		// binary 모드인 경우 PE 파일이 아니라도 오픈 시도하도록 설정
		forceOpen = hashMode.compare(_T("b")) == 0;

		// 파일 오픈 시도(binary 모드인 경우 PE 파일이 아니라도 오픈 시도)
		if (!(isOpen = peparser.open(filePath, forceOpen)))
		{				
			// 실패 시 프로세스 오픈 시도
			if ((isOpen = peparser.open(processID)) && (useProcessImage == 0))
			{
				// useProcessImage 값이 0이면 프로세스에 연결된 파일로 부터 해시 추출
				if ((isOpen = peparser.parsePE(PE_DIRECTORY_DEBUG)))
				{
					filePath = peparser.getPEStructure().filePath;
					peparser.close();
					isOpen = peparser.open(filePath);
				}
			}
		}

		if (isOpen)
		{
			// PE 구조체 참조 설정
			const auto& peStruct = peparser.getPEStructure();

			if (hash.open())
			{
				// Hash mode 에 따른 처리
				if (hashMode.compare(_T("b")) == 0)
				{
					// 파일 바이너리 해시 추출 - PE 분석이 필요 없음
					if (hash.calculateHash(reinterpret_cast<const PBYTE>(peStruct.baseAddress), peStruct.sizeOfImage, true))
					{
							tcout << format(_T("File binary hash = {}"), hash.getHashString()) << endl;
					}
				}
				else if (hashMode.compare(_T("c")) == 0)
				{
					// PE 헤더 부분만 파싱
					if (peparser.parsePE(PE_DIRECTORY_NONE))
					{
						if (hash.calculateHash(reinterpret_cast<const PBYTE>(peStruct.addressOfCodeSection), peStruct.sizeOfCodeSection, true))
						{
							tcout << format(_T("Code hash = {}"), hash.getHashString()) << endl;
						}
					}
				}
				else if (hashMode.compare(_T("p")) == 0)
				{
					// PE 헤더 + DEBUG_DIRECTORY 부분 파싱
					if (peparser.parsePE(PE_DIRECTORY_DEBUG))
					{
						char8_t* pdbPathPtr = const_cast<char8_t*>(peStruct.pdbFileInfo.u8FilePath.data());
						if (hash.calculateHash(reinterpret_cast<const PBYTE>(pdbPathPtr), peStruct.pdbFileInfo.u8FilePath.size(), true))
						{
							tcout << format(_T("PDB file hash = {}"), hash.getHashString()) << endl;
						}
					}
				}
				else
				{
					tcout << cmdParser.getHelpMessage(_T("HashTool"));
				}
				hash.close();
			}
			peparser.close();
		}
		else
		{
			tcout << cmdParser.getHelpMessage(_T("HashTool"));
		}
	}
	return 0;
};
