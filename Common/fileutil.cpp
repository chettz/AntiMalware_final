#include "fileutil.h"

namespace fileutil
{
    // "" 문자로 감싸여진 경로 추출
    bool FileUtil::extractString(const tstring& orgPath, const tstring& startMarker, const tstring& endMarker, tstring& subString)
    {
        bool result = false;

        size_t startPos = orgPath.find(startMarker);
        if (startPos != std::string::npos)
        {
            startPos += startMarker.length();  // 시작 마커 이후의 첫 번째 문자 위치

            size_t endPos = orgPath.find(endMarker, startPos);
            if (endPos != std::string::npos)
            {
                subString = orgPath.substr(startPos, endPos - startPos);
                result = TRUE;
            }
        }
        return result;
    };

    // 실제 경로 추출 - 환경 변수가 포함된 경로에서 실제 경로 얻기
    bool FileUtil::getRealPath(const tstring& orgPath, tstring& realPath)
    {
        bool result = true;
        DWORD covertResult = 0;
        BinaryData pathBuffer(4096); // 4k 경로 버퍼 생성

        // 원본 경로 설정
        realPath = orgPath;

        // \" 문자로 묶인 경로인 경우 \" 사이의 실제 경로만 추출
        if (orgPath.find(_T('\"')) != tstring::npos)
        {
            if (extractString(orgPath, _T("\""), _T("\""), realPath))
            {
                realPath = canonical(realPath).c_str();
            }
        }

        // % 문자가 포함된 경로는 환경 변수가 포함된 경로이기 때문에
        // ExpandEnvironmentStrings() 함수로 실제 경로를 얻음
        if (orgPath.find(_T('%')) != tstring::npos)
        {
            covertResult = ExpandEnvironmentStrings(orgPath.c_str(), reinterpret_cast<LPTSTR>(pathBuffer.data()), MAX_PATH);
            if (covertResult > 0 && (covertResult < (MAX_PATH * 8)))
            {
                realPath = reinterpret_cast<LPTSTR>(pathBuffer.data());
            }
        }
        return result;
    };

    // 파일 제거 - 핸들이 열려 있어서 제거되지 않는 경우 재부팅 시 제거되도록 설정
    bool FileUtil::removeFile(const tstring& filePath, bool& needReboot)
    {
        bool result = false;

        try
        {
            needReboot = false;

            if (exists(filePath))
            {
                if (!remove(filePath))
                {
                    needReboot = MoveFileEx(filePath.c_str(), NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
                }
            }
            result = exists(filePath);
        }
        catch (...)
        {

        }
        return result;
    }

    // 현재 디렉토리를 리턴
    const tstring FileUtil::getCurrentPath(void)
    {
        return current_path();
    };

    // 파일 스캔 스레드 중지
    void FileUtil::stopSearchFiles(void)
    {
        if (isSearchAlive_)
        {
            // 감시 중단 설정
            searchContinue_ = false;

            // 최대 100ms 만큼 종료 대기
            for (int loop = 0; loop < 100; loop++)
            {
                Sleep(1);
                if (!isSearchAlive_)
                {
                    break;
                }
            }
        }
    };

    // 파일 스캔 스레드 시작
    void FileUtil::startSearchFiles(const tstring& parentDirectory, size_t& currentFileCount, function<void(tstring)> scanCallback)
    {
        thread processThread = thread([&]() { searchFiles(parentDirectory, currentFileCount, scanCallback); });
        processThread.detach();
    };

    // 파일 스캔 함수
    void FileUtil::searchFiles(const tstring& parentDirectory, size_t& currentFileCount, function<void(tstring)> scanCallback)
    {
        // 최상위 디렉토리 설정
        path parent(parentDirectory);
        if (exists(parent))
        {
            // Traverse all directories and files recursively
            for (const auto& entry : recursive_directory_iterator(parent, directory_options::skip_permission_denied))
            {
                try
                {
                    if (entry.is_regular_file())
                    {
                        scanCallback(entry.path());
                        currentFileCount++;
                    }
                    Sleep(0);
                }
                catch (const std::exception& ex)
                {
                    logger_.log(format("Error : {:x}, {}", GetLastError(), ex.what()), LOG_LEVEL_ERROR);
                    logger_.log(format(_T("    {}"), entry.path().c_str()), LOG_LEVEL_ERROR);
                    continue;
                }

                // 스캔 중지
                if (searchContinue_)
                {
                    break;
                }
            }
        }
    };
}