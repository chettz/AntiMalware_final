#include "scanengine.h"

namespace scanengine
{
    // 소멸자
    ScanEngine::~ScanEngine()
    {
        close();
    };

    // 핸들 및 변수 초기화
    void ScanEngine::close(void)
    {
        for (auto element : fileMappingInfo_)
        {
            if (element.fileMappingHandle != NULL)
            {
                UnmapViewOfFile(element.baseAddress);
                CloseHandle(element.fileMappingHandle);
                element.fileMappingHandle = NULL;
            }
            if (element.fileHandle != INVALID_HANDLE_VALUE)
            {
                CloseHandle(element.fileHandle);
                element.fileHandle = INVALID_HANDLE_VALUE;
            }
        }
        initialized_ = false;
    };

    // 지정된 DB 파일로 부터 파일 맵핑 생성
    bool ScanEngine::createFileMappingInfo(const tstring& filePath, FILE_MAPPING_INFO& fileMappingInfo)
    {
        bool result = false;

        fileMappingInfo.fileHandle = CreateFile(filePath.c_str(),
            GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY, NULL);

        if (fileMappingInfo.fileHandle != INVALID_HANDLE_VALUE)
        {
            fileMappingInfo.fileMappingHandle = CreateFileMapping(fileMappingInfo.fileHandle, NULL, PAGE_READONLY, 0, 0, NULL);
            if (fileMappingInfo.fileMappingHandle != NULL)
            {
                fileMappingInfo.baseAddress = static_cast<PBYTE>(MapViewOfFile(fileMappingInfo.fileMappingHandle, FILE_MAP_READ, 0, 0, 0));
                if (fileMappingInfo.baseAddress != NULL)
                {
                    result = true;
                }
            }
        }
        if (!result)
        {
            logger_.log(format(_T("Error: {}, createFileMappingInfo fail : {}"), GetLastError(), filePath), LOG_LEVEL_ERROR);
        }
        return result;
    };

    // 검사 엔진 초기화 - db 초기화
    bool ScanEngine::initialize(const tstring& dbDirPath)
    {
        if (!initialized_)
        {
            tstring dirPath = current_path();

            // 지정된 경로가 있으면 해당 경로에서 db 초기화
            if (!dbDirPath.empty())
            {
                dirPath = dbDirPath;
            }

            // 악성코드 db 파일에서 파일 맵핑 생성 - 초기화
            tstring loadFilePath = path(dirPath).append(DB_FILE_NAME).c_str() + tstring(DB_FILE_EXT_NAME);
            if (createFileMappingInfo(loadFilePath, fileMappingInfo_[DB_FILE_NAME_INDEX]))
            {
                loadFilePath = path(dirPath).append(DB_FILE_NAME).c_str() + tstring(DB_FILE_EXT_FILTER);
                if (createFileMappingInfo(loadFilePath, fileMappingInfo_[DB_FILE_FILTER_INDEX]))
                {
                    loadFilePath = path(dirPath).append(DB_FILE_NAME).c_str() + tstring(DB_FILE_EXT_HASH);
                    initialized_ = createFileMappingInfo(loadFilePath, fileMappingInfo_[DB_FILE_HASH_INDEX]);
                }
            }
            if (!initialized_)
            {
                close();
            }
            return initialized_;
        }
        else        
        {
            logger_.log(format(_T("Warning: {}, ScanEngine is aready initilized"), GetLastError()), LOG_LEVEL_WARN);
            return false;
        }
    };

    // 탐지명이 저장된 파일의 offset을 이용하여 탐지명을 얻기 위한 함수
    bool ScanEngine::getDetectName(const DWORD& nameOffset, tstring& detectName)
    {
        bool result = false;
        PBYTE baseAddress = fileMappingInfo_[DB_FILE_NAME_INDEX].baseAddress;

        if (baseAddress != NULL)
        {
            // 파일에 저장되어 있는 탐지명은 UTF-8 문자열
            detectName = strConv_.to_tstring(reinterpret_cast<char8_t*>(baseAddress + nameOffset));
            result = !detectName.empty();
        }
        return result;
    }

    // 블룸 필터에 존재하는 지 여부 체크
    bool ScanEngine::checkFilter(const BinaryData& hashData, WORD& crcHash)
    {
        bool result = false;
        BYTE hashValue[BLOOM_FILTER_HASH_FUNCTION_COUNT][BYTE_COUNT_DWORD] = { 0, };
        DWORD bitIndex = 0;
        Hash filterHash;

        if (filterHash.open(HASH_TYPE_CRC16))
        {
            // CRC16 + MD5 첫 번쨰 바이트로 첫 번째 해시 함수의 24bit 해시 값으로 설정
            if (filterHash.calculateHash(hashData.data(), static_cast<DWORD>(hashData.size())))
            {
                // CRC16 해시 얻음
                const BinaryData& hashBytes = filterHash.getHashBytes();
                memcpy(hashValue[0], hashBytes.data(), sizeof(WORD));

                // CRC16 해시 값은 실제 해시 테이블 검색 시에도 사용되므로 전달
                crcHash = *(reinterpret_cast<PWORD>(hashValue[0]));

                // CRC16(2byte) + MD5 첫 번째 바이트(1byte)로 24bit(3byte) 값 설정
                hashValue[0][2] = hashData[0];
            }
            filterHash.close();

            // MD5 해시 값 hashData[1] ~ hashData[15]에서 3byte 씩 나눠서 해시 함수의 24bit 해시 값으로 설정 
            for (int index = 1; index < BLOOM_FILTER_HASH_FUNCTION_COUNT; index ++)
            {
                memcpy(hashValue[index], (hashData.data() + (index * BYTE_COUNT_24BIT) - 2), BYTE_COUNT_24BIT);
            }
        }

        // BLOOM_FILTER_HASH_FUNCTION_COUNT개의 해시 값의 위치에 비트가 모두 1로 설정 되어 있는지 체크
        for (int index = 0; index < BLOOM_FILTER_HASH_FUNCTION_COUNT; index++)
        {
            // 값을 얻기 위한 bit 위치 설정
            bitIndex = *(reinterpret_cast<PDWORD>(hashValue[index]));

            // bitIndex 위치의 bit 값 읽기
            const PBYTE& bloomFilter = fileMappingInfo_[DB_FILE_FILTER_INDEX].baseAddress;
            result = static_cast<bool>(bloomFilter[bitIndex / 8] & BIT_FLAG[7 - (bitIndex % 8)]);
            if (!result)
            {
                break;
            }
        }
        return result;
    };

    // 해시 테이블에 존재하는 지 여부 체크
    bool ScanEngine::checkHashTable(const BinaryData& hashData, const WORD& crcHash, tstring& detectName)
    {
        bool result = FALSE;
        PDWORD bucketItemPtr = NULL;
        PLINKED_LIST_ITEM linkedListItemPtr = NULL;
        PBYTE baseAddress = fileMappingInfo_[DB_FILE_HASH_INDEX].baseAddress;
        DWORD nextItemIndex = 0;
        DWORD hashSize = sizeof(LINKED_LIST_ITEM::hash);

        if (baseAddress != NULL)
        {
            linkedListItemPtr = reinterpret_cast<PLINKED_LIST_ITEM>(baseAddress + HASH_TABLE_BUCKET_SIZE);

            // CRC16 해시값 위치의 버킷에 등록된 최초 인덱스 정보를 읽어옴
            bucketItemPtr = reinterpret_cast<PDWORD>(baseAddress);
            nextItemIndex = bucketItemPtr[crcHash];
            if (nextItemIndex != 0xffffffff)
            {
                // 인덱스 정보가 0이 아닌 경우 해시 테이블을 순회하면서 실제 등록된 해시 값과 비교
                do
                {
                    // 인덱스 위치의 LINKED_LIST_ITEM의 해시 값이 주어진 해시 값과 일치하는 지 여부 체크(std::equal 함수 사용)
                    if (equal(linkedListItemPtr[nextItemIndex].hash, linkedListItemPtr[nextItemIndex].hash + hashSize, hashData.data()))
                    {
                        // 해시 값이 일치하는 경우 해당 LINKED_LIST_ITEM의 detectNameOffset을 이용하여 탐지명이 저장된 파일에서 탐지명을 읽어 옴
                        result = getDetectName(linkedListItemPtr[nextItemIndex].detectNameOffset, detectName);
                        break;
                    }
                    nextItemIndex = linkedListItemPtr[nextItemIndex].nextIndex;
                } 
                while (nextItemIndex != 0);
            }
        }
        return result;
    };

    // 특정 해시 값이 악성코드 해시 값인지 여부 확인
    bool ScanEngine::scanHash(const BinaryData& hashData, tstring& detectName)
    {
        bool result = false;
        WORD crcHash = 0;

        if (initialized_)
        {
            // 블룸 필터에 존재하는지 체크
            if (checkFilter(hashData, crcHash))
            {
                // 해시 테이블에 존재하는 지 체크
                result = checkHashTable(hashData, crcHash, detectName);
            }
        }
        else
        {
            logger_.log(format(_T("Error: {}, ScanEngine is not initialized"), GetLastError()), LOG_LEVEL_ERROR);
        }
        return result;
    };

    // 특정 해시 값이 악성코드 해시 값인지 여부 확인
    bool ScanEngine::scanHash(const tstring& hashString, tstring& detectName)
    {
        Hash hash;
        return scanHash(hash.getHashBytesFromHexString(hashString), detectName);
    };

    // 파일 검사 함수
    bool ScanEngine::scanFile(const tstring& filePath, tstring& detectName)
    {
        bool result = false;
        PEParser parser;
        Hash hash;

        if (parser.open(filePath))
        {
            // 파일 검사인 경우 PE 분석을 하지 않아도 됨
            const PE_STRUCT& peStruct = parser.getPEStructure();

            if (hash.open(HASH_TYPE_MD5))
            {
                if (hash.calculateHash(reinterpret_cast<const BYTE*>(peStruct.baseAddress), peStruct.sizeOfImage, true))
                {
                    result = scanHash(hash.getHashBytes(), detectName);
                }
                hash.close();
            }

            // PEParser close
            parser.close();
        }
        return result;
    };

    // 프로세스 검사 함수
    bool ScanEngine::scanProcess(const DWORD& pid, tstring& detectName)
    {
        bool result = false;
        PEParser parser;

        if (parser.open(pid))
        {
            // 프로세스인 경우 프로세스의 실제 파일을 검사
            result = scanFile(parser.getPEStructure().filePath, detectName);

            // PEParser close
            parser.close();
        }
        return result;
    };
}