#pragma once

#include <iostream>
#include <string>
#include <format>
#include <vector>
#include <queue>
#include <map>
#include <tchar.h>
#include <typeinfo>
#include <string>
#include <string_view>
#include <algorithm>
#include "windows.h"

// tcout 정의
#ifndef tcout
#if defined(UNICODE) || defined(_UNICODE)
	#define tcout wcout
#else
	#define tcout cout
#endif
#endif

// 객체 해제 및 NULL 설정을 위한 매크로 정의
// OBJECT_CLEAR(var, CloseHandle); => if (var != NULL) { CloseHandle(var); var = NULL; };
#define OBJECT_CLEAR(target, function) { if ((target != NULL) && (target != INVALID_HANDLE_VALUE)) { function(target); target = NULL; } }

// TCHAR를 다룰 문자열 형식 정의
typedef std::basic_string<TCHAR> tstring;
typedef std::basic_string_view<TCHAR> tstring_view;

// 바이너리 데이터 저장을 위한 형식 정의
typedef std::vector<BYTE> BinaryData;

// 텍스트 데이터 저장을 위한 형식 정의
typedef std::vector<TCHAR> TextData;

// 유니코드 문자 저장을 위한 형식 정의
typedef std::vector<WCHAR> UnocodeString;

// 파일에 객체를 저장하기 위한 탬플릿 선언
template<typename T1, typename T2>
std::ostream& write_typed_data(std::ostream& stream, const T1& value, const T2& valueLength)
{
    return stream.write(reinterpret_cast<const char*>(value.data()), valueLength);
};

// 파일에 저장된 객체를 읽기 위한 탬플릿 선언
template<typename T1, typename T2>
std::istream& read_typed_data(std::istream& stream, T1& value, const T2& valueLength)
{
    return stream.read(reinterpret_cast<char*>(value.data()), valueLength);
};

