#include "ipc.h"

namespace ipc 
{
    // 생성자
    IPC::IPC() 
        : isOpened_(false), isServer_(false), securityAttributes_({ 0, }),
        mutexHandle_(NULL), serverEventHandle_(NULL), clientEventHandle_(NULL), 
        sharedMemHandle_(NULL), sharedMemBuffer_(NULL), sharedMemSize_(0) // , command_(NULL) 
    {
        // Initialize a security descriptor
        InitializeSecurityDescriptor(&securityDescriptor_, SECURITY_DESCRIPTOR_REVISION);
        SetSecurityDescriptorDacl(&securityDescriptor_, TRUE, NULL, FALSE);

        // Initialize a security attributes structure
        securityAttributes_.nLength = sizeof(securityDescriptor_);
        securityAttributes_.lpSecurityDescriptor = &securityDescriptor_;
        securityAttributes_.bInheritHandle = FALSE;
    };

    // 소멸자
    IPC::~IPC(void)
    {
        close();
    };

    // IPC 사용 가능 여부
    bool IPC::isOpen(void) const
    {
        return isOpened_;
    };

    // 공유 메모리 생성 또는 오픈
    bool IPC::initializeFileMapping(const bool& create, const DWORD& bufferSize)
    {
        if (create)
        {
            // 파일 매핑 생성
            sharedMemHandle_ = CreateFileMapping(
                INVALID_HANDLE_VALUE,  // 파일 핸들
                NULL,                  // 보안 속성
                PAGE_READWRITE,        // 메모리 보호 옵션
                0,                     // 공유 메모리 최대 크기(high-order DWORD)
                bufferSize,            // 공유 메모리 최대 크기(low-order DWORD)
                IPC_SHARED_MEMORY_NAME // 공유 메모리 이름
            );
        }
        else
        {
            // 파일 매핑 오픈
            sharedMemHandle_ = OpenFileMapping(
                FILE_MAP_ALL_ACCESS,   // 파일 매핑 개체에 대한 액세스 권한
                FALSE,                 // 핸들 상속 여부
                IPC_SHARED_MEMORY_NAME // 공유 메모리 이름
            );
        }

        // 파일 매핑을 프로세스의 주소 공간에 매핑
        if (sharedMemHandle_ != NULL)
        {
            sharedMemBuffer_ = static_cast<PBYTE>(MapViewOfFile(
                sharedMemHandle_,      // 공유 메모리 핸들
                FILE_MAP_ALL_ACCESS,   // 메모리 접근 권한
                0,                     // 공유 메모리 위치의 오프셋
                0,                     // 공유 메모리 위치의 오프셋
                sharedMemSize_         // 매핑할 영역의 크기
            ));
            if (sharedMemBuffer_ != NULL)
            {
                sharedMemSize_ = bufferSize;
            }
        }
        return (sharedMemBuffer_ != NULL);
    };

    // 뮤텍스 생성 또는 오픈 - 공유 메모리 동시 접근 보호
    bool IPC::initializeMutex(const bool& create)
    {
        if (create)
        {
            // 뮤텍스 생성
            mutexHandle_ = CreateMutex(
                NULL,                   // 보안 설정 - SECURITY_ATTRIBUTES 구조체에 대한 포인터
                FALSE,                  // initially not owned (mutex 생성과 동시에 소유 할 것인지 여부)
                IPC_MUTEX_NAME          // 뮤텍스 이름
            );
        }
        else
        {
            // 뮤텍스 오픈
            mutexHandle_ = OpenMutex(
                SYNCHRONIZE,            // 뮤텍스에 대한 액세스 권한(사용을 위해서는 SYNCHRONIZE 권한만 필요)
                FALSE,                  // 핸들 상속 여부
                IPC_MUTEX_NAME          // 뮤텍스 이름
            );
        }
        return (mutexHandle_ != NULL);
    }

    // 이벤트 생성 또는 오픈 - 메시지 송수신용
    bool IPC::initializeEvent(const bool& create)
    {
        if (create)
        {
            // 이벤트 생성
            serverEventHandle_ = CreateEvent(
                &securityAttributes_,                 // SECURITY_ATTRIBUTES 구조체에 대한 포인터
                FALSE,                                // if TRUE, the function creates a manual-reset event object
                FALSE,                                // if TRUE, the initial state of the event object is signaled; otherwise, it is nonsignaled.
                IPC_SERVER_EVENT_NAME                 // 이벤트 이름
            );
            if (serverEventHandle_ != NULL)
            {
                clientEventHandle_ = CreateEvent(
                    &securityAttributes_,
                    FALSE,
                    FALSE,
                    IPC_CLIENT_EVENT_NAME
                );
            }
        }
        else
        {
            // 이벤트 오픈
            serverEventHandle_ = OpenEvent(
                SYNCHRONIZE | EVENT_MODIFY_STATE,     // 이벤트에 대한 액세스 권한(사용을 위해서는 SYNCHRONIZE + EVENT_MODIFY_STATE 권한 필요)
                FALSE,                                // 핸들 상속 여부
                IPC_SERVER_EVENT_NAME                 // 이벤트 이름
            );
            if (serverEventHandle_ != NULL)
            {
                clientEventHandle_ = OpenEvent(
                    SYNCHRONIZE | EVENT_MODIFY_STATE, 
                    FALSE,                            
                    IPC_CLIENT_EVENT_NAME             
                );
            }
        }
        return (clientEventHandle_ != NULL);
    };

    // 메시지 전송
    bool IPC::sendMsg(const IPC_MESSAGE& ipcMessage)
    {
        bool result = false;
        DWORD waitResult = 0;

        if (isOpened_ && (sharedMemHandle_ != NULL) && (mutexHandle_ != NULL))
        {
            // mutex 점유를 위해서 대기
            // mutex가 아무도 점유하지 않고 있는 signaled 상태가 될 때까지 대기)
            // mutex를 점유하면 non-signaled 상태로 변경
            waitResult = WaitForSingleObject(mutexHandle_, INFINITE);
            if (waitResult == WAIT_OBJECT_0)
            {
                // Shared memory clear
                memset(sharedMemBuffer_, 0x0, sharedMemSize_);

                // 메시지 기록
                memcpy_s(sharedMemBuffer_, IPC_MEMORY_BUFFER_SIZE, &ipcMessage.ipcHeader, sizeof(ipcMessage.ipcHeader));
                memcpy_s(sharedMemBuffer_ + sizeof(ipcMessage.ipcHeader), IPC_MEMORY_BUFFER_SIZE - sizeof(ipcMessage.ipcHeader), 
                    ipcMessage.ipcData.data(), ipcMessage.ipcData.size());
            }
            else
            {
                logger_.log(_T("WaitForSingleObject(Mutex) fail"), GetLastError(), LOG_LEVEL_ERROR);
            }

            // Release ownership of the mutex object
            if (!ReleaseMutex(mutexHandle_))
            {
                // Handle error.
                logger_.log(_T("ReleaseMutex fail"), GetLastError(), LOG_LEVEL_ERROR);
            }

            // 메시지 수신 처리를 위한 이벤트 처리
            if (isServer_)
            {
                // Server인 경우 Client 쪽 수신 이벤트 상태 설정(signaled)
                ResetEvent(serverEventHandle_);
                result = SetEvent(clientEventHandle_);
            }
            else
            {
                // Client인 경우 Server 쪽 수신 이벤트 상태 설정(signaled)
                ResetEvent(clientEventHandle_);
                result = SetEvent(serverEventHandle_);
            }
        }
        return result;
    };
    
    // 메시지 수신
    bool IPC::receiveMsg(IPC_MESSAGE& ipcMessage, IPCCommandType acceptCommandType)
    {
        bool result = false;
        DWORD waitResult = 0;

        if (isOpened_ && (sharedMemHandle_ != NULL) && (mutexHandle_ != NULL))
        {
            // mutex 점유를 위해서 대기
            // mutex가 아무도 점유하지 않고 있는 signaled 상태가 될 때까지 대기)
            // mutex를 점유하면 non-signaled 상태로 변경
            waitResult = WaitForSingleObject(mutexHandle_, INFINITE);
            if (waitResult == WAIT_OBJECT_0)
            {
                // 메시지 복원 - 명령
                memcpy_s(&ipcMessage.ipcHeader, sizeof(ipcMessage.ipcHeader), sharedMemBuffer_, sizeof(ipcMessage.ipcHeader));

                // 메시지가 있고, 읽어야 할 메시지인 경우에만 처리
                if ((ipcMessage.ipcHeader.ipcCommand & acceptCommandType) > 0x0)
                {
                    // 메시지 복원 - 데이터
                    ipcMessage.ipcData.resize(ipcMessage.ipcHeader.ipcDataSize);
                    memcpy_s(ipcMessage.ipcData.data(), ipcMessage.ipcData.size(), sharedMemBuffer_ + sizeof(ipcMessage.ipcHeader), ipcMessage.ipcData.size());

                    // Shared memory clear
                    memset(sharedMemBuffer_, 0x0, sharedMemSize_);

                    result = true;
                }
            }
            else
            {
                logger_.log(_T("WaitForSingleObject(Mutex) fail"), GetLastError(), LOG_LEVEL_ERROR);
            }

            // Release ownership of the mutex object
            if (!ReleaseMutex(mutexHandle_))
            {
                // Handle error.
                logger_.log(_T("ReleaseMutex fail"), GetLastError(), LOG_LEVEL_ERROR);
            }
        }
        return result;
    };

    // IPC 열기
    bool IPC::open(const bool& ipcCreate, const DWORD& bufferSize)
    {
        bool result = false;

        // IPC 생성(Server) or 오픈(Client)
        if (initializeFileMapping(ipcCreate) &&
            initializeMutex(ipcCreate) &&
            initializeEvent(ipcCreate))
        {
            isOpened_ = true;
            isServer_ = ipcCreate;
            result = true;
        }
        else
        {
            logger_.log(format(_T("IPC open fail - 0x{:x}"), GetLastError()), LOG_LEVEL_ERROR);
            close();
        }
        return result;
    }

    // IPC 닫기
    void IPC::close(void)
    {
        if (isOpened_)
        {
            // 감시 중단 설정
            isOpened_ = false;

            // 감시 중단을 위해 뮤텍스 및 이벤트 대기 해제
            SetEvent(mutexHandle_);
            SetEvent(serverEventHandle_);
            SetEvent(clientEventHandle_);

            // 100ms 만큼 대기(안전한 종료를 위해)
            Sleep(100);
        }

        // 객체 및 핸들 해제
        OBJECT_CLEAR(sharedMemBuffer_, UnmapViewOfFile);
        OBJECT_CLEAR(sharedMemHandle_, CloseHandle);
        OBJECT_CLEAR(serverEventHandle_, CloseHandle);
        OBJECT_CLEAR(clientEventHandle_, CloseHandle);
        OBJECT_CLEAR(mutexHandle_, CloseHandle);
    };

    bool IPC::getNextInfo(IPC_MESSAGE& ipcData, IPCCommandType acceptCommandType)
    {
        bool result = false;
        
        // 메시지 수신을 위한 이벤트 대기
        if (isServer_)
        {
            // Server인 경우 Server 쪽 수신 이벤트 대기
            WaitForSingleObject(serverEventHandle_, INFINITE);
        }
        else
        {
            // Client인 경우 Client 쪽 수신 이벤트 대기
            WaitForSingleObject(clientEventHandle_, INFINITE);
        }

        // 메시지 수신
        if (isOpened_)
        {
            if (receiveMsg(ipcData, acceptCommandType))
            {
                result = true;
            }
        }
        return result;
    };

};
