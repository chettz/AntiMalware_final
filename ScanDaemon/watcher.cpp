#pragma once

#include "watcher.h"

namespace watcher
{
	Watcher::Watcher() 
		: isAlive_(false), watchingFlag_(false), getNextInfoEvent_(0)
	{
		const tstring& eventName = strConv_.to_tstring(to_wstring(reinterpret_cast<size_t>(this)));

		// 이벤트 생성
		getNextInfoEvent_ = CreateEvent(
			NULL,                  // SECURITY_ATTRIBUTES 구조체에 대한 포인터
			FALSE,                 // if TRUE, the function creates a manual-reset event object
			FALSE,                 // if TRUE, the initial state of the event object is signaled; otherwise, it is nonsignaled.
			eventName.c_str()      // 이벤트 이름
		);
	};

	Watcher::~Watcher()
	{
		// 감시 스레드 중지
		stopMonitoring();

		// 이벤트 핸들 해제
		OBJECT_CLEAR(getNextInfoEvent_, CloseHandle);
	};

	// 감시 스레드 동작 여부 리턴
	bool Watcher::isAlive(void) const
	{
		return isAlive_;
	};

	// 감시 시작
	bool Watcher::startMonitoring(void)
	{
		bool result = false;

		if (!isAlive_)
		{
			// 감시 시작 설정
			isAlive_ = true;
			watchingFlag_ = true;

			// thread 생성 시 람다 함수에 [&]를 사용하면 
			// 기본적으로 람다 함수 외부의 변수에 대해서 참조로 캡처하기 때문에
			// thread로 실행되는 람다 함수 내에서 클래스 내부 변수들 사용 가능
			thread watchThread = thread([&]() { watchThreadFunc(); });

			// 생성된 스레드를 독립적으로 동작 시키기 위해서 detatch() 호출
			watchThread.detach();

			result = true;
		}
		return result;
	};

	// 감시 종료
	void Watcher::stopMonitoring(void)
	{
		if (isAlive_)
		{
			// 감시 중단 설정
			watchingFlag_ = false;

			// 이벤트 대기 해제
			SetEvent(getNextInfoEvent_);

			// 최대 100ms 만큼 종료 대기
			for (int loop = 0; loop < 5000; loop++)
			{
				Sleep(1);
				if (!isAlive_)
				{
					break;
				}
			}
		}
	};

	// 파일 이벤트 발생 시 파일 정보를 전달 받을 콜백 함수
	void Watcher::eventCallback(const EVENT_INFO& eventInfo)
	{
		// std::lock_guard라는 클래스는 객체가 생성 될때 생성자에서 lock를 하며, 이 객체가 소멸 될 때 unlock
		// unlock을 호출하지 않는 실수 방지
		lock_guard<mutex> guard(eventInfoLock_);
		{
			eventInfoList_.push(eventInfo);
		}
		SetEvent(getNextInfoEvent_);
	};

	// 현재까지 발생한 이벤트 정보를 얻기 위한 함수
	bool Watcher::getNextInfo(EVENT_INFO& eventInfo)
	{
		bool result = false;

		if (watchingFlag_)
		{
			// 이벤트 설정 때까지 대기
			if (eventInfoList_.empty())
			{
				WaitForSingleObject(getNextInfoEvent_, INFINITE);
			}
			else
			{
				// std::lock_guard라는 클래스는 객체가 생성 될때 생성자에서 lock를 하며, 이 객체가 소멸 될 때 unlock
				// unlock을 호출하지 않는 실수 방지
				lock_guard<mutex> guard(eventInfoLock_);
				{
					// 맨 처음 등록된 파일 정보 복사
					eventInfo = eventInfoList_.front();

					// 복사한 파일 정보 제거
					eventInfoList_.pop();
				}
				result = true;
			}
		}
		return result;
	};
}
