#include "cmdparser.h"
#include "scanengine.h"
#include "filewatcher.h"
#include "processwatcher.h"
#include "regwatcher.h"
#include "ipc.h"

using namespace cmdparser;
using namespace scanengine;
using namespace watcher;
using namespace ipc;

// 파일 감시 스레드
void fileWatchThread(FileWatcher& fileWatcher, const tstring& dbDirectory)
{
	ScanEngine scanEngine;
	EVENT_INFO eventInfo;
	tstring detectName;

	// ScanEngine 초기화
	scanEngine.initialize(dbDirectory);

	// UNC Path를 안쓰는 경우 파일 경로가 MAX_PATH를 넘어가면 오류 발생할 수 있음
	if (fileWatcher.setBaseDirectory(_T("\\\\?\\c:\\")))
	{
		// 감시 시작
		fileWatcher.startMonitoring();

		// 감시 항목 처리
		while (fileWatcher.isAlive())
		{
			if (fileWatcher.getNextInfo(eventInfo) && (eventInfo.eventType == FILE_EVENT))
			{
				if (scanEngine.scanFile(eventInfo.Path, detectName))
				{
					tcout << endl << format(_T("{:s} detected!\n  >> {:s}"), detectName, eventInfo.Path) << endl;
				}
			}
		}
	}
};

// 프로세스 감시 스레드
void processWatchThread(ProcessWatcher& processWatcher, const tstring& dbDirectory)
{
	ScanEngine scanEngine;
	EVENT_INFO eventInfo;
	tstring detectName;

	// ScanEngine 초기화
	scanEngine.initialize(dbDirectory);

	// 감시 시작
	processWatcher.startMonitoring();

	// 감시 항목 처리
	while (processWatcher.isAlive())
	{
		if (processWatcher.getNextInfo(eventInfo) && (eventInfo.eventType == PROCESS_EVENT))
		{
			if (scanEngine.scanFile(eventInfo.Path, detectName))
			{
				tcout << endl << format(_T("{:s} detected!\n  >> {:s}"), detectName, eventInfo.Path) << endl;
			}
		}
	}
};

// 레지스트리 감시 스레드
void regWatchThread(RegWatcher& regWatcher, const tstring& dbDirectory)
{
	ScanEngine scanEngine;
	EVENT_INFO eventInfo;
	tstring detectName;

	// ScanEngine 초기화
	scanEngine.initialize(dbDirectory);

	// 감시 대상 레지스트리 키 설정
	if (regWatcher.setBaseRegKey(REG_HKEY_LOCAL_MACHINE, _T("HKEY_LOCAL_MACHINE"), _T("Software\\Microsoft\\Windows\\CurrentVersion\\Run")))
	{
		// 감시 시작
		regWatcher.startMonitoring();

		// 감시 항목 처리
		while (regWatcher.isAlive())
		{
			if (regWatcher.getNextInfo(eventInfo) && (eventInfo.eventType == REG_EVENT))
			{
				if (scanEngine.scanFile(eventInfo.Path, detectName))
				{
					tcout << endl << format(_T("{:s} detected!\n  >> {:s}"), detectName, eventInfo.Path) << endl;
				}
			}
		}
	}
};

void ipcProcThread(IPC& ipc, const tstring& dbDirectory)
{
	bool result = false;
	DWORD scanPID = 0;
	tstring scanPath;
	tstring scanHash;
	tstring detectName;
	IPC_MESSAGE ipcMessage;
	ScanEngine scanEngine;
	IPCCommandType acceptCommandType = static_cast<IPCCommandType>(IPC_SCAN_FILE | IPC_SCAN_PROCESS | IPC_SCAN_HASH);

	// 스캔 엔진 초기화
	scanEngine.initialize(dbDirectory);

	// IPC 처리
	while (ipc.isOpen())
	{
		if (ipc.getNextInfo(ipcMessage, acceptCommandType))
		{
			result = false;

			if (ipcMessage.ipcHeader.ipcCommand == IPC_SCAN_FILE)
			{
				scanPath = reinterpret_cast<TCHAR*>(ipcMessage.ipcData.data());
				result = scanEngine.scanFile(scanPath, detectName);
			}
			else if (ipcMessage.ipcHeader.ipcCommand == IPC_SCAN_PROCESS)
			{
				scanPID = (*(reinterpret_cast<PDWORD>(ipcMessage.ipcData.data())));
				result = scanEngine.scanProcess(scanPID, detectName);
			}
			else if (ipcMessage.ipcHeader.ipcCommand == IPC_SCAN_HASH)
			{
				scanHash = reinterpret_cast<TCHAR*>(ipcMessage.ipcData.data());
				result = scanEngine.scanHash(scanHash, detectName);
			}
			if (result)
			{
				ipcMessage.ipcHeader.ipcCommand = IPC_SCAN_RESULT_DETECT;
				ipcMessage.ipcHeader.ipcDataSize = static_cast<DWORD>(detectName.size() + 1) * sizeof(TCHAR);
				ipcMessage.ipcData.resize(ipcMessage.ipcHeader.ipcDataSize);
				memcpy_s(ipcMessage.ipcData.data(), ipcMessage.ipcData.size(), detectName.data(), ipcMessage.ipcHeader.ipcDataSize);
			}
			else
			{
				ipcMessage.ipcHeader.ipcCommand = IPC_SCAN_RESULT_NOT_DETECT;
				ipcMessage.ipcHeader.ipcDataSize = 0;
				ipcMessage.ipcData.clear();
			}
			ipc.sendMsg(ipcMessage);
		}
	};
};

// 키 입력이 있을 떄 까지 대기
void waitForKeyInput(void)
{
	HANDLE stdinHandle = GetStdHandle(STD_INPUT_HANDLE);
	INPUT_RECORD irInBuf = { 0, };
	DWORD readLength = 0;
	DWORD waitResult = 0;

	// 디버깅 상태가 아닌 cmd 창에서 실행 시 VK_ENTER 키가 자동적으로 입력이 되므로 제거
	if (!IsDebuggerPresent())
	{
		ReadConsoleInput(stdinHandle, &irInBuf, 1, &readLength);
	}

	// 키 입력 대기
	while (true)
	{
		waitResult = WaitForSingleObject(stdinHandle, 100);
		if (waitResult == WAIT_TIMEOUT)
		{
			continue;
		}
		else if (waitResult == WAIT_OBJECT_0)
		{
			if (ReadConsoleInput(stdinHandle, &irInBuf, 1, &readLength) &&
				(irInBuf.EventType == KEY_EVENT))
			{
				break;
			}
		}
		Sleep(1);
	}
};

tstring getCommandOption(int argc, TCHAR* argv[])
{
	CmdParser cmdParser;
	tstring dbDirectory;
	
	// 옵션 등록
	cmdParser.set_optional<tstring>(_T("d"), _T("db_file_directory"), _T(""), _T("The malware db file's directory."));

	// 커맨드라인 파싱
	cmdParser.parseCmdLine(argc, argv);
		
	if (cmdParser.isPrintHelp())
	{
		// 도움말 옵션 설정 시 도움말 출력
		tcout << cmdParser.getHelpMessage(_T("ScanDaemon"));
	}
	else
	{
		try
		{
			dbDirectory = cmdParser.get<tstring>(_T("d"));
		}
		catch (std::runtime_error ex)
		{
			// 오류 발생 시에 오류 내용과 함께 도움말 출력
			cout << format("Error : {}\n\n", ex.what());
			tcout << cmdParser.getHelpMessage(_T("ScanDaemon"));
		}
	}
	return dbDirectory;
};

int _tmain(int argc, TCHAR* argv[])
{
	// 유니코드 출력시 로케일 설정이 필요
	// 시스템의 기본 로케일을 따르도록 설정
	setlocale(LC_ALL, "");

	// 파라미터 읽기
	tstring dbDirectory = getCommandOption(argc, argv);

	// IPC 스레드 실행
	IPC ipc;
	{
		// IPC 초기화
		ipc.open(TRUE);

		// C++ thread는 생성과 동시에 시작되며
		// thread 생성 시 람다 함수에 [&]를 사용하면 
		// 기본적으로 람다 함수 외부의 변수에 대해서 참조로 캡처
		// 람다 함수 문법 및 캡처 표현 참고
		// [captures](parameters) -> return type { body }  
		// captures '&' means "capture by reference".
		// captures '=' means "capture by value".
		thread ipcThread = thread([&]() { ipcProcThread(ipc, dbDirectory); });

		// 생성된 thread를 독립적으로 동작 시키기 위해서 detatch() 호출 
		// join()을 호출하는 경우에는 join() 함수 내에서 종료 시 까지 대기
		ipcThread.detach();
	}

	// 파일 감시 스레드 실행
	FileWatcher fileWatcher;
	{
		thread fileThread = thread([&]() { fileWatchThread(fileWatcher, dbDirectory); });
		fileThread.detach();
	}

	// 프로세스 감시 스레드 실행
	ProcessWatcher processWatcher;
	{
		thread processThread = thread([&]() { processWatchThread(processWatcher, dbDirectory); });
		processThread.detach();
	}

	// 레지스트리 감시 스레드 실행
	RegWatcher regWatcher;
	{
		thread regThread = thread([&]() { regWatchThread(regWatcher, dbDirectory); });
		regThread.detach();
	}

	// 메시지 출력 후 키 입력 시 까지 대기
	tcout << endl << _T("Scan daemon is running....\nPress any key to exit.") << endl;
	waitForKeyInput();

	// IPC 및 감시 스레드 종료
	{
		ipc.close();
		fileWatcher.stopMonitoring();
		processWatcher.stopMonitoring();
		regWatcher.stopMonitoring();
	}
	return 0;
}
