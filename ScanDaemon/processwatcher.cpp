#include "processwatcher.h"

#pragma comment(lib, "wbemuuid.lib")

namespace watcher
{
    // 감시 스레드
    void ProcessWatcher::watchThreadFunc(void)
    {
        HRESULT hr = NULL;
        IWbemLocator* pLocator = nullptr;
        IWbemServices* pServices = nullptr;
        IUnsecuredApartment* pUnsecApp = nullptr;
        EventSink* pSink = nullptr;
        IUnknown* pStubUnk = nullptr;
        IWbemObjectSink* pStubSink = nullptr;


        // Initialize COM
        if (SUCCEEDED(CoInitializeEx(nullptr, COINIT_MULTITHREADED)))
        {
            // Initialize security
            hr = CoInitializeSecurity(nullptr, -1, nullptr, nullptr, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, nullptr, EOAC_NONE, nullptr);
            if (SUCCEEDED(hr))
            {
                // Obtain the initial locator to WMI
                hr = CoCreateInstance(CLSID_WbemLocator, nullptr, CLSCTX_INPROC_SERVER, IID_IWbemLocator, reinterpret_cast<LPVOID*>(&pLocator));
                if (SUCCEEDED(hr))
                {
                    hr = pLocator->ConnectServer(_bstr_t(L"ROOT\\CIMV2"), nullptr, nullptr, nullptr, 0, nullptr, nullptr, &pServices);
                    if (SUCCEEDED(hr))
                    {
                        // Set the security levels on the proxy
                        hr = CoSetProxyBlanket(pServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, nullptr, RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IMPERSONATE, nullptr, EOAC_NONE);
                        if (SUCCEEDED(hr))
                        {
                            // Set up the event notification query
                            hr = CoCreateInstance(CLSID_UnsecuredApartment, nullptr, CLSCTX_LOCAL_SERVER, IID_IUnsecuredApartment, reinterpret_cast<void**>(&pUnsecApp));
                            if (SUCCEEDED(hr))
                            {
                                // Create an instance of the EventSink class
                                // EventSink sink;
                                // sink.setCallback(this);
                                pSink = new EventSink;
                                pSink->setCallbackClass(this);
                                pSink->AddRef();

                                hr = pUnsecApp->CreateObjectStub(pSink, &pStubUnk);
                                if (SUCCEEDED(hr))
                                {
                                    // Set up the event consumer
                                    hr = pStubUnk->QueryInterface(IID_IWbemObjectSink, reinterpret_cast<void**>(&pStubSink));
                                    if (SUCCEEDED(hr))
                                    {
                                        // Execute the query asynchronously
                                        hr = pServices->ExecNotificationQueryAsync(
                                            _bstr_t(L"WQL"),
                                            _bstr_t(L"SELECT * FROM __InstanceCreationEvent WITHIN 1 WHERE TargetInstance ISA 'Win32_Process'"),
                                            WBEM_FLAG_SEND_STATUS,
                                            nullptr,
                                            pStubSink
                                        );
                                        if (SUCCEEDED(hr))
                                        {
                                            // 프로세스 감시 종료시 까지 대기 (Async 방식이기 때문)
                                            while (watchingFlag_)
                                            {
                                                // 1000 ns == 0.001 ms
                                                this_thread::sleep_for(std::chrono::nanoseconds(1000));
                                            }

                                            // Cancel the event notification
                                            pServices->CancelAsyncCall(pSink);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // 처리 과정에서 오류 발생 시 로그 출력
            if (FAILED(hr))
            {
                logger_.log(format(_T("ProcessWatcher::watchThreadFunc fail : {:x}"), hr), LOG_LEVEL_ERROR);
            }

            // Cleanup
            if (pServices != nullptr) pServices->Release();
            if (pLocator != nullptr) pLocator->Release();
            if (pUnsecApp != nullptr) pUnsecApp->Release();
            if (pStubUnk != nullptr) pStubUnk->Release();
            if (pSink != nullptr) pSink->Release();
            if (pStubSink != nullptr) pStubSink->Release();

            // COM Uninitialize
            CoUninitialize();
        }

        // 감시 스레드 종료 설정
        isAlive_ = false;
    };

    HRESULT STDMETHODCALLTYPE EventSink::QueryInterface(REFIID riid, void** ppv)
    {
        if (riid == IID_IUnknown || riid == IID_IWbemObjectSink)
        {
            *ppv = (IWbemObjectSink*)this;
            return S_OK;
        }
        else
        {
            return E_NOINTERFACE;
        }
    };

    HRESULT STDMETHODCALLTYPE EventSink::Indicate(LONG lObjectCount, IWbemClassObject** apObjArray)
    {
        VARIANT var;
        VARIANT varObject;
        HRESULT hr = NULL;
        DWORD pid = 0;
        tstring processName;
        tstring processPath;
        tstring processCmdLine;

        VariantInit(&var);
        VariantInit(&varObject);

        for (int i = 0; i < lObjectCount; ++i)
        {
            hr = apObjArray[i]->Get(L"TargetInstance", 0, &var, nullptr, nullptr);
            if (SUCCEEDED(hr))
            {
                IWbemClassObject* pProcess = nullptr;
                hr = var.pdispVal->QueryInterface(IID_IWbemClassObject, reinterpret_cast<void**>(&pProcess));
                if (SUCCEEDED(hr))
                {
                    if (SUCCEEDED(pProcess->Get(L"ProcessID", 0, &varObject, nullptr, nullptr)))
                    {
                        pid = varObject.uintVal;
                    }
                    VariantClear(&varObject);
                    if (SUCCEEDED(pProcess->Get(L"Name", 0, &varObject, nullptr, nullptr)) && varObject.vt == VT_BSTR)
                    {
                        processName = varObject.bstrVal;
                    }
                    VariantClear(&varObject);
                    if (SUCCEEDED(pProcess->Get(L"ExecutablePath", 0, &varObject, nullptr, nullptr)) && varObject.vt == VT_BSTR)
                    {
                        processPath = varObject.bstrVal;
                    }
                    VariantClear(&varObject);
                    if (SUCCEEDED(pProcess->Get(L"CommandLine", 0, &varObject, nullptr, nullptr)) && varObject.vt == VT_BSTR)
                    {
                        processCmdLine = varObject.bstrVal;
                    }
                    VariantClear(&varObject);
                    pProcess->Release();

                    // 콜백 함수를 호출히여 정보 전달
                    if (callbackClassPtr_ != nullptr)
                    {
                        callbackClassPtr_->eventCallback(EVENT_INFO{ PROCESS_EVENT, PROCESS_EVENT_CREATED, pid, processPath, processName, processCmdLine });
                    }
                }
                Sleep(0);
            }
        }
        VariantClear(&var);
        VariantClear(&var);
        return WBEM_S_NO_ERROR;
    };

    // 프로세스 이벤트 발생 시 호출 할 함수의 클래스 설정
    void EventSink::setCallbackClass(ProcessWatcher* callbackClassPtr)
    {
        callbackClassPtr_ = callbackClassPtr;
    };


}