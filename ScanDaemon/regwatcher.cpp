#include "regwatcher.h"

namespace watcher
{
    // 소멸자 - 감시 대상 키를 닫아주기 위해서 재정의
    RegWatcher::~RegWatcher()
    {
        stopMonitoring();
        if (baseRegKey_ != NULL)
        {
            RegCloseKey(baseRegKey_);
            baseRegKey_ = NULL;
        }
    };

    // 변경된 레지스트리 값이 있으면 정보 전달
    // 감시 시작 때 기존 항목들도 검사 
    void RegWatcher::notifyNewVaue(void)
    {
        DWORD valueNumber = 0;
        DWORD maxValueLength = 0;
        DWORD maxValueNameLength = 0;
        DWORD valueNameSize = 0;
        DWORD valueType = 0;
        DWORD valueDataSize = 0;
        TextData valueName;
        TextData valueData;
        tstring realPath;
        bool isNew = false;

        if (RegQueryInfoKey(baseRegKey_, NULL, 0, 0, NULL, NULL, NULL, &valueNumber, 
            &maxValueNameLength, &maxValueLength, NULL, NULL) == ERROR_SUCCESS)
        {
            maxValueNameLength += 1; // NULL 문자 추가해야 함(NULL 문자 미 포함 길이가 리턴 되기 때문)
            maxValueLength += sizeof(TCHAR); // NULL 문자 공간 할당
            valueName.assign(maxValueNameLength, 0);
            valueData.assign(maxValueLength / sizeof(TCHAR), 0);
            valueNameSize = static_cast<DWORD>(valueName.size());
            valueDataSize = static_cast<DWORD>(valueData.size());

            for (DWORD index = 0; index < valueNumber; index++)
            {
                if (RegEnumValueW(baseRegKey_, index, valueName.data(), &valueNameSize, NULL, &valueType, 
                    reinterpret_cast<LPBYTE>(valueData.data()), &valueDataSize) == ERROR_SUCCESS)
                {
                    if ((valueType == REG_SZ) || (valueType == REG_EXPAND_SZ))
                    {
                        // 기존에 존재하던 항목인지 여부 체크
                        const auto& iter = regValueMap_.find(valueName.data());
                        if (iter != regValueMap_.end())
                        {
                            // 기존에 존재하던 항목인 경우 실제 값이 같은지 비교
                            if (isNew = (tstring_view(valueData.data()).compare(iter->second) != 0))
                            {
                                // 새로운 항목이라면 기존 항목을 제거
                                // std::map의 insert() 함수는 키가 존재하는 경우 같은 키값으로 새로운 값을 저장할 수 없음
                                regValueMap_.erase(iter);
                            }
                        }
                        else
                        {
                            isNew = true;
                        }
                        if (isNew)
                        {
                            // 신규 항목 추가
                            regValueMap_.insert(pair(valueName.data(), valueData.data()));

                            // 콜백 함수를 호출히여 정보 전달
                            const path& filePath = path(valueData.data());
                            if (fileUtil_.getRealPath(filePath, realPath) && exists(realPath))
                            {
                                eventCallback(EVENT_INFO{ REG_EVENT, REG_EVENT_CREATED, 0, realPath, valueName.data(), valueData.data() });
                            }
                        }
                    }
                }
                // 변수 초기화
                std::fill(valueName.begin(), valueName.end(), 0);
                std::fill(valueData.begin(), valueData.end(), 0);
                valueNameSize = static_cast<DWORD>(valueName.size());
                valueDataSize = static_cast<DWORD>(valueData.size());
            }
        }
    };

	// 감시할 레지스트리 키 설정
	bool RegWatcher::setBaseRegKey(const RegRootKey& rootKey, const tstring& rootKeyName, const tstring& baseSubKey)
	{
        bool result = false;

        if (SUCCEEDED(RegOpenKeyEx(reinterpret_cast<HKEY>(rootKey), baseSubKey.c_str(), 0, KEY_READ, &baseRegKey_)))
        {
            rootRegKey_ = rootKey;
            rootRegKeyName_ = rootKeyName;

            // 기존에 존재하던 레지스트리 값들을 맵에 등록
            regValueMap_.clear();
            notifyNewVaue();

            result = true;
        }
        else
        {
			baseRegKey_ = NULL;
            rootRegKey_ = REG_HKEY_NONE;
            logger_.log(format(_T("Can't open base key : {}, {}"), rootKeyName, baseSubKey), LOG_LEVEL_ERROR);
        }
        return result;
	};

	// 감시 스레드
	void RegWatcher::watchThreadFunc(void)
	{
        if (baseRegKey_ != NULL)
        {
            HANDLE eventHandle = NULL;
            DWORD waitObject = 0;

            // Create an event.
            if ((eventHandle = CreateEvent(NULL, TRUE, FALSE, NULL)) != NULL)
            {
                while (watchingFlag_)
                {
                    // Watch the registry key for a change of value.
                    if (RegNotifyChangeKeyValue(baseRegKey_, FALSE, REG_LEGAL_CHANGE_FILTER, eventHandle, TRUE) != ERROR_SUCCESS)
                    {
                        logger_.log(format(_T("RegWatcher::RegNotifyChangeKeyValue fail : {:x}"), GetLastError()), LOG_LEVEL_ERROR);
                        break;
                    }
                    else
                    {
                        // Wait for an event to occur. 100ms wait 
                        waitObject = WaitForSingleObject(eventHandle, 100);
                        if (waitObject == WAIT_FAILED) {
                            break;
                        }
                        else if (waitObject == WAIT_TIMEOUT) {
                            continue; 
                        }
                        else
                        {
                            // 새로 변경된 값이 있으면 정보 전달
                            // RegNotifyChangeKeyValue 함수는 변경 여부만 알려주기 때문에 실제 변경된 값들은 쿼리해서 알아내야 함
                            notifyNewVaue();
                        }
                    }

                    // 1000 ns == 0.001 ms
                    this_thread::sleep_for(std::chrono::nanoseconds(1000));
                }

                // Close the handle.
                CloseHandle(eventHandle);
            }
        }
		// 감시 스레드 종료 설정
		isAlive_ = false;
	};
}
