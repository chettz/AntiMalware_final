#include "filewatcher.h"

namespace watcher
{
    // 감시 대상 루트 경로 설정
    bool FileWatcher::setBaseDirectory(const tstring& rootDirectory)
    {
        bool result = false;

        if (result = exists(rootDirectory))
        {
            uncRootPath_ = rootDirectory;
            normalRootPath_ = rootDirectory;

            if (uncRootPath_.starts_with(_T("\\\\?\\")))
            {
                normalRootPath_.erase(0, 4);
            }
        }
        else
        {
            logger_.log(format(_T("Can't find base directory : {}"), rootDirectory), LOG_LEVEL_ERROR);
        }
        return result;
    };

    void FileWatcher::stopMonitoring(void)
    {
        SetEvent(dirEventHandle_);
        Watcher::stopMonitoring();
    }

    // 감시 스레드
    void FileWatcher::watchThreadFunc(void)
    {
        BinaryData watchBuffer(FILE_WATCH_BUFFER_SIZE); // 버퍼 크기 : FILE_WATCH_BUFFER_SIZE (32k)
        PFILE_NOTIFY_INFORMATION pfni = nullptr;
        OVERLAPPED dirOverlap{ 0 };
        HANDLE dirHandle = INVALID_HANDLE_VALUE;
        DWORD bytesReturned = 0;
        tstring fileFullPath;
        tstring fileName;
        tstring fileExt;

        if (!uncRootPath_.empty())
        {
            dirHandle = CreateFile(uncRootPath_.c_str(),
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED,  // FILE_FLAG_BACKUP_SEMANTICS 필수
                NULL
            );
            if (dirHandle == INVALID_HANDLE_VALUE)
            {
                logger_.log(_T("Failed to open directory."), GetLastError(), LOG_LEVEL_ERROR);
            }
            else
            {
                dirEventHandle_ = CreateEvent(0, 0, 0, 0);
                dirOverlap.hEvent = dirEventHandle_;

                while (watchingFlag_)
                {
                    // 비동기(Asynchronous) 방식으로 ReadDirectoryChangesW 호출 (OVERLAPPED 설정)
                    if (!ReadDirectoryChangesW(
                        dirHandle,
                        watchBuffer.data(),
                        static_cast<DWORD>(watchBuffer.size()),
                        TRUE,   // watch sub directory
                        FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_SIZE | 
                        FILE_NOTIFY_CHANGE_CREATION | FILE_NOTIFY_CHANGE_LAST_ACCESS,
                        &bytesReturned,
                        &dirOverlap,
                        NULL))
                    {
                        logger_.log(_T("Error reading directory changes."), LOG_LEVEL_ERROR);
                        break;
                    }
                    else
                    {
                        // 비동기 방식에서의 파일 이벤트 수신 대기
                        if (!GetOverlappedResult(dirHandle, &dirOverlap, &bytesReturned, TRUE))
                        {
                            // ERROR_IO_PENDING 등의 이유로 실패가 리턴되면 다시 ReadDirectoryChangesW 호출
                            continue;
                        }
                    }

                    // 파일 이벤트 정보 읽음
                    pfni = reinterpret_cast<PFILE_NOTIFY_INFORMATION>(watchBuffer.data());

                    // 파일 이벤트 처리
                    while (watchingFlag_)
                    {
                        // 이벤트에 따른 파일 경로 정보 추출 
                        if ((pfni->Action == FILE_EVENT_CREATED) || (pfni->Action == FILE_EVENT_RENAMED_NEW))
                        {
                            // 전달되는 문자열이 유니코드 문자열이기 때문에 tstring로 변환
                            const path& relativePath = path(strConv_.to_tstring(wstring_view(pfni->FileName, pfni->FileNameLength)));

                            // 파일명 설정, c_str()을 사용해야 잘못된 문자열이 설정되는 걸 막을 수 있음
                            fileName = relativePath.native().c_str();

                            // 파일 전체 경로 길이가 MAX_PATH를 넘어서는 경우 정상적인 처리가 안되기 때문에
                            // UNC path를 이용해야 함, UNC path는 길이가 32,767 까지 가능
                            if ((normalRootPath_.size() + fileName.size()) > MAX_PATH)
                            {
                                fileFullPath = path(uncRootPath_).append(fileName).c_str();
                            }
                            else
                            {
                                fileFullPath = path(normalRootPath_).append(fileName).c_str();
                            }
                            fileExt = relativePath.extension().c_str();

                            // 파일 확장자 설정
                            if (!fileExt.empty() && fileExt[0] == _T('.'))
                            {
                                // 파일 확장자에 '.'이 포함되기 떄문에 제거
                                fileExt = fileExt.erase(0, 1);
                            }

                            // 일정 시간이상 대시 하지 않고 바로 검사 작업이 이루어지게 되면 Sharing Violation 오류 발생
                            // 10000 ns == 0.01 ms
                            if (watchingFlag_)
                            {
                                this_thread::sleep_for(std::chrono::nanoseconds(10000));
                            }

                            // 콜백 함수를 호출히여 정보 전달
                            eventCallback(EVENT_INFO{ FILE_EVENT, EventSubType(pfni->Action), 0, fileFullPath, fileName, fileExt });
                        }
                        if (pfni->NextEntryOffset == 0)
                        {
                            // pfni->NextEntryOffset가 0일 때도 마지막 항목이 저장되어 있기 때문에 확인 지점 설정이 중요
                            break;
                        }
                        pfni = (FILE_NOTIFY_INFORMATION*)((PBYTE)pfni + pfni->NextEntryOffset);
                    }

                    // 버퍼를 0으로 초기화
                    fill(watchBuffer.begin(), watchBuffer.end(), 0);
                }
            }
        }
        else
        {
            logger_.log(_T("The root directory isn't set."), LOG_LEVEL_ERROR);
        }

        // 핸들 닫기
        OBJECT_CLEAR(dirEventHandle_, CloseHandle);
        OBJECT_CLEAR(dirHandle, CloseHandle);

        // 감시 스레드 종료 설정
        isAlive_ = false;
    };
}