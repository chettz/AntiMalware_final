#include "ipc.h"
#include "logger.h"
#include "cmdparser.h"
#include<tlhelp32.h> // 프로세스 이름으로 ID를 찾기위한 헤더파일
#include<filesystem>

using namespace ipc;
using namespace logging;
using namespace cmdparser;

// 옵션 등록
void configureCmdParser(CmdParser& cmdParser)
{
    cmdParser.set_optional<tstring>(_T("f"), _T("file_path"), _T(""), _T("The target file path."));
    cmdParser.set_optional<DWORD>(_T("p"), _T("process_id"), 0, _T("The target process id."));
    cmdParser.set_optional<tstring>(_T("h"), _T("hash_string"), _T(""), _T("Hash string for scan."));
    // 탐지된 프로세스 종료를 위한 옵션 등록
    cmdParser.set_optional<tstring>(_T("k"), _T("target_process"), _T(""), _T("The target process name"));

    // cmdParser.set_optional<tstring>(_T("d"), _T("target_PID"), _T(""), _T("PID of file to delete"));

};

// 옵션 값 읽기
bool readCmdLineOption(CmdParser& cmdParser, tstring& scanMode, tstring& filePath, DWORD& processID, tstring& hashString, tstring& processName)
{
    bool result = false;

    if (cmdParser.isPrintHelp())
    {
        // 도움말 옵션 설정 시 도움말 출력
        tcout << cmdParser.getHelpMessage(_T("ScanCLI"));
    }
    else
    {
        try
        {
            // 커맨드라인 옵션 읽기
            filePath = cmdParser.get<tstring>(_T("f"));
            processID = cmdParser.get<DWORD>(_T("p"));
            hashString = cmdParser.get<tstring>(_T("h"));
            // 추가한 옵션
            processName = cmdParser.get<tstring>(_T("k"));

            result = true;
        }
        catch (std::runtime_error ex)
        {
            // 오류 발생 시에 오류 내용과 함께 도움말 출력
            cout << format("Error : {}\n\n", ex.what());
            tcout << cmdParser.getHelpMessage(_T("ScanCLI"));
        }
    }
    return result;
};

// 파일 검사 요청
bool ScanFile(IPC_MESSAGE& ipcMessage, const tstring& filePath, IPC& ipc, tstring& detectName)
{
    // 파일 검사 요청을 위한 정보 설정
    ipcMessage.ipcHeader.ipcCommand = IPC_SCAN_FILE;
    ipcMessage.ipcHeader.ipcDataSize = static_cast<DWORD>(filePath.size() + 1) * sizeof(TCHAR);
    ipcMessage.ipcData.resize(ipcMessage.ipcHeader.ipcDataSize);
    memcpy_s(ipcMessage.ipcData.data(), ipcMessage.ipcData.size(), filePath.data(), ipcMessage.ipcHeader.ipcDataSize);

    // 검사 요청
    return ipc.sendMsg(ipcMessage);
};

// 프로세스 검사 요청
bool ScanProcess(IPC_MESSAGE& ipcMessage, const DWORD& processID, IPC& ipc, tstring& detectName)
{
    // 파일 검사 요청을 위한 정보 설정
    ipcMessage.ipcHeader.ipcCommand = IPC_SCAN_PROCESS;
    ipcMessage.ipcHeader.ipcDataSize = sizeof(processID);
    ipcMessage.ipcData.resize(ipcMessage.ipcHeader.ipcDataSize);
    memcpy_s(ipcMessage.ipcData.data(), ipcMessage.ipcData.size(), &processID, ipcMessage.ipcHeader.ipcDataSize);

    // 검사 요청
    return ipc.sendMsg(ipcMessage);
};

// 해시 검사 요청
bool ScanHash(IPC_MESSAGE& ipcMessage, const tstring& hashString, IPC& ipc, tstring& detectName)
{
    // 파일 검사 요청을 위한 정보 설정
    ipcMessage.ipcHeader.ipcCommand = IPC_SCAN_HASH;
    ipcMessage.ipcHeader.ipcDataSize = static_cast<DWORD>(hashString.size() + 1) * sizeof(TCHAR);
    ipcMessage.ipcData.resize(ipcMessage.ipcHeader.ipcDataSize);
    memcpy_s(ipcMessage.ipcData.data(), ipcMessage.ipcData.size(), hashString.data(), ipcMessage.ipcHeader.ipcDataSize);

    // 검사 요청
    return ipc.sendMsg(ipcMessage);
};

// processID로 프로세스 강제 종료 요청
bool KillProcess(DWORD processID) {
    // 프로세스에 종료 권한을 넘겨주어 TerminateProcess() API 실행
    HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, processID); 
    if (hProcess == NULL) {
        tcout << _T("OpenProcess is failed\n");
        return false;
    }

    if (!TerminateProcess(hProcess, 0)) { // 프로세스 종료 API 호출
        tcout << _T("TerminateProcess is failed\n");
        CloseHandle(hProcess);
        return false;
    }

    CloseHandle(hProcess);
    return true;
}

// 파일이름으로 프로세스의 ID 찾기
DWORD FindProcessID(tstring& processName) {
    HANDLE hProcessSnap;
    PROCESSENTRY32 pe32; // 프로세스 정보를 저장하는 구조체
    DWORD processID = 0;

    // 프로세스 스냅샷 생성 후 프로세스 목록을 가져옴
    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hProcessSnap == INVALID_HANDLE_VALUE) {
        tcout << _T("CreateToolhelp32Snapshot is failed\n");
        return 0;
    }

    pe32.dwSize = sizeof(PROCESSENTRY32); // dwSize를 구조체 크기로 초기화

    if (!Process32First(hProcessSnap, &pe32)) {
        tcout << _T("Process32First is failed\n");
        CloseHandle(hProcessSnap);
        return 0;
    }

    do { // 현재 프로세스 목록 순회
        if (_wcsicmp(pe32.szExeFile, processName.c_str()) == 0) { // 전달받은 프로세스 이름과 현재 스냅샷에서의 프로세스에 대한 이름과 비교
            processID = pe32.th32ProcessID; // 일치하면 해당 스냅샷에서의 프로세스 ID를 저장
            break;
        }
    } while (Process32Next(hProcessSnap, &pe32)); // 동일한 스냅샷에 대한 다음 프로세스 검색

    CloseHandle(hProcessSnap);
    return processID;
}

// 프로세스 ID로 해당 프로세스의 파일 경로를 구함
tstring GetProcessFilePath(DWORD processID) {
    HANDLE hModuleSnap;
    MODULEENTRY32 me32;
    tstring filePath;

    // 전달받은 해당 프로세스의 모든 항목의 스냅샷을 구함
    hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPALL, processID); 
    if (hModuleSnap == INVALID_HANDLE_VALUE) {
        tcout << _T("CreateToolhelp32Snapshot is failed\n");
        return L"";
    }

    me32.dwSize = sizeof(MODULEENTRY32); // 구조체 사이즈 초기화

    if (!Module32First(hModuleSnap, &me32)) {
        tcout << _T("Module32First is failed\n");
        CloseHandle(hModuleSnap);
        return L"";
    }

    // 첫 번째 모듈의 실행파일 경로 반환
    filePath = me32.szExePath;

    CloseHandle(hModuleSnap);
    return filePath;
}

// 프로세스가 존재하는 파일경로의 실행파일 삭제
bool DeleteExe(tstring& exePath) {
    if (DeleteFile(exePath.c_str())) {
        tcout << format(_T("Successfully deleted file: {}\n"), exePath);
        return true;
    }
    else {
        tcout << format(_T("Failed to delete file: {}\n"), exePath);
        return false;
    }
}

int _tmain(int argc, TCHAR* argv[])
{
    // 유니코드 출력시 로케일 설정이 필요
    // 시스템의 기본 로케일을 따르도록 설정
    setlocale(LC_ALL, "");

    Logger logger; 
    CmdParser cmdParser;

    // 옵션 변수 선언
    tstring scanMode;
    tstring filePath;
    DWORD processID;
    tstring hashString;
    // 추가로 옵션 변수 선언
    tstring processName;

    // 옵션 등록
    configureCmdParser(cmdParser);

    // 커맨드라인 파싱
    cmdParser.parseCmdLine(argc, argv);

    // 옵션 값 읽기
    if (readCmdLineOption(cmdParser, scanMode, filePath, processID, hashString, processName))
    {
        IPC ipc;
        IPC_MESSAGE ipcMessage;
        tstring detectedName;
        bool sendMessage = false;

        if (ipc.open(false))
        {
            // 옵션에 따른 검사 요청
            if (!filePath.empty())
            {
                tcout << format(_T("ScanFile : {}\n"), filePath);
                sendMessage = ScanFile(ipcMessage, filePath, ipc, detectedName);
            }
            else if (processID > 4)
            {
                tcout << format(_T("ScanProcess : {}\n"), processID);
                sendMessage = ScanProcess(ipcMessage, processID, ipc, detectedName);
            }
            else if (!hashString.empty())
            {
                tcout << format(_T("ScanHash : {}\n"), hashString);
                sendMessage = ScanHash(ipcMessage, hashString, ipc, detectedName);
            }
            // 새로운 옵션 추가_ 탐지된 프로세스 강제 종료
            else if (!processName.empty())
            {
                do
                {   // 같은 이름을 가진 프로세스가 여러 개 실행되고 있을 수 있으므로 PID값이 0이 아니면 반복
                    DWORD PID;
                    PID = FindProcessID(processName);
                    KillProcess(PID);
                    tcout << format(_T("KillProcess_PID : {}_{}\n"), processName, PID);
                } while(FindProcessID(processName)!=0);
            }
            // 새로운 옵션 추가 - 실행 파일 삭제
            else
            {
                tcout << format(_T("The scan option is not defined.\n"));
            }

            // 검사 요청 후 검사 결과 수신
            if (sendMessage)
            {
                IPCCommandType acceptCommandType = static_cast<IPCCommandType>(IPC_SCAN_RESULT_DETECT | IPC_SCAN_RESULT_NOT_DETECT);

                // 검사 결과 수신
                if (ipc.getNextInfo(ipcMessage, acceptCommandType))
                {
                    // 탐지 시 탐지명 설정
                    if (ipcMessage.ipcHeader.ipcCommand == IPC_SCAN_RESULT_DETECT)
                    {
                        detectedName = reinterpret_cast<TCHAR*>(ipcMessage.ipcData.data());
                    }
                    if (!detectedName.empty())
                    {
                        tcout << format(_T("  >> DETECTED: {}\n"), detectedName);
                       
                        if (processID != 0)
                        {
                            tcout << format(_T("Do you want to delete the file of PID_{}?"), processID) << _T(" (Y/n): ");
                            string response;
                            std::cin >> response;

                            if (response == "Y") 
                            {
                                tstring exePath;
                                exePath = GetProcessFilePath(processID);
                                KillProcess(processID); // 삭제하기 전에 실행 중이 프로세스 종료
                                Sleep(5000); // 기존에 Sleep() 없이 진행했더니 파일이 삭제되지 않는 오류 발생 
                                // => 프로세스가 종료되지 않으면 실행파일이 삭제되지 않으므로 프로세스 종료와 실행파일 삭제 동작간에 텀을 주었음
                                if (!DeleteExe(exePath)) {
                                    // tcout << _T("Error: Could not delete the executable\n");
                                    return 1;
                                }
                            }
                            else
                            {
                                tcout << _T("Cancel file deletion\n");
                            }

                        }
                    }
                    else
                    {
                        tcout << _T("  >> NOT DETECTED\n");
                    }
                }
            }
        }
        else
        {
            logger.log(_T("Can't start IPC"), LOG_LEVEL_ERROR);
        }
    }
    return 0;
}
